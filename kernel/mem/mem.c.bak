/*
 * Simple kernel heap allocator (first-fit with splitting & coalescing)
 *
 * Uses linker-provided symbols:
 *   extern char _heap_start[];
 *   extern char _heap_end[];
 *
 * Optional locking: define HAVE_LOCK and provide lock.h with
 *  void lock_acquire(void);
 *  void lock_release(void);
 *
 * Overhead: each allocated block has a header:
 *   struct block_hdr {
 *     size_t size;      // payload size (not including header)
 *     struct block_hdr *next;
 *     unsigned free:1;  // 1 if free, 0 if used (packed bit)
 *   };
 *
 * Alignment: 8 bytes by default.
 */

#include "mem.h"
#include <stdint.h>
#include <stddef.h>
#include "../sync/lock.h"
#include "../uart/uart.h"
#include "../include/color.h"
/* Optional lock: user may define HAVE_LOCK and provide lock.h */

/* Linker symbols (must be defined in linker script) */
extern char _heap_start[]; /* inclusive */
extern char _heap_end[];   /* exclusive */

/* configuration */
#define MEM_ALIGN 8u
#define HDR_ALIGN sizeof(uintptr_t) /* ensure header aligned */

typedef struct block_hdr {
    size_t size;                 /* payload size */
    struct block_hdr *next;      /* next block in free/used list (used only for free list) */
    unsigned free:1;             /* 1 free, 0 used */
    /* padding if necessary */
} block_hdr_t;

/* compute header size rounded up to alignment */
static inline size_t hdr_size(void) {
    size_t s = sizeof(block_hdr_t);
    size_t m = (s + (MEM_ALIGN-1)) & ~(MEM_ALIGN-1);
    return m;
}

/* start of heap and limit */
static uint8_t *heap_start;
static uint8_t *heap_end;

/* free list head (singly-linked by hdr->next) */
static block_hdr_t *free_head = NULL;

/* statistics */
static size_t total_free_bytes = 0;
static size_t total_used_bytes = 0;

/* helpers */
static inline uintptr_t align_up_uintptr(uintptr_t v, uintptr_t a) {
    return (v + (a - 1)) & ~(a - 1);
}

/* split a free block if it's much larger than requested */
static void split_block(block_hdr_t *b, size_t req_size) {
    size_t hsz = hdr_size();
    /* if remaining space after allocation can hold a header + minimal payload (align to MEM_ALIGN) */
    if (b->size >= req_size + hsz + MEM_ALIGN) {
        uint8_t *base = (uint8_t *)b;
        uint8_t *new_block_addr = base + hsz + req_size;
        new_block_addr = (uint8_t *)align_up_uintptr((uintptr_t)new_block_addr, MEM_ALIGN);

        block_hdr_t *nb = (block_hdr_t *)new_block_addr;
        nb->size = b->size - ( (new_block_addr - base) - hsz );
        nb->next = b->next;
        nb->free = 1;

        b->size = req_size;
        b->next = nb;

        total_free_bytes -= hsz; /* header moved to new block; adjust not precise but ok */
    }
}

/* remove a free block from free list (prev may be NULL) */
static void remove_free_block(block_hdr_t *prev, block_hdr_t *b) {
    if (prev)
        prev->next = b->next;
    else
        free_head = b->next;
    b->next = NULL;
    b->free = 0;
}

/* find first-fit block; return (prev, found) via pointers */
static block_hdr_t *find_fit(size_t req_size, block_hdr_t **out_prev) {
    block_hdr_t *prev = NULL;
    block_hdr_t *cur = free_head;
    while (cur) {
        if (cur->free && cur->size >= req_size) {
            if (out_prev) *out_prev = prev;
            return cur;
        }
        prev = cur;
        cur = cur->next;
    }
    if (out_prev) *out_prev = NULL;
    return NULL;
}

/* coalesce adjacent free blocks in the free list (linear scan) */
static void coalesce_all(void) {
    /* We assume the blocks in memory order; our free list may not be sorted.
       To keep implementation simple, we rebuild a sorted free list by address and merge adjacent blocks.
    */
    /* Count free blocks */
    int count = 0;
    for (block_hdr_t *b = free_head; b; b = b->next) count++;

    if (count <= 1) return;

    /* collect pointers into array on stack if small, otherwise fallback simple bubble insertion */
    /* For simplicity, we will do insertion sort into a local array if count reasonable */
    #define MAX_FAST 256
    block_hdr_t *arr[MAX_FAST];
    block_hdr_t **list = arr;
    int idx = 0;
    if (count > MAX_FAST) {
        /* too many, skip full coalesce (rare in small kernels) */
        return;
    }
    for (block_hdr_t *b = free_head; b; b = b->next) {
        arr[idx++] = b;
    }
    /* sort by address (simple insertion sort) */
    for (int i = 1; i < idx; ++i) {
        block_hdr_t *key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j+1] = arr[j];
            --j;
        }
        arr[j+1] = key;
    }
    /* rebuild free_head and merge adjacent */
    free_head = NULL;
    block_hdr_t *prev = NULL;
    for (int i = 0; i < idx; ++i) {
        block_hdr_t *b = arr[i];
        if (prev && ((uint8_t *)prev + hdr_size() + prev->size == (uint8_t *)b)) {
            /* adjacent: merge b into prev */
            prev->size += hdr_size() + b->size;
            total_free_bytes += hdr_size(); /* header removal approximate */
            continue;
        } else {
            /* append */
            if (!free_head) free_head = b;
            if (prev) prev->next = b;
            prev = b;
        }
    }
    if (prev) prev->next = NULL;
}

/* extend heap: try to carve new block at heap_curr up to heap_end */
static int extend_heap(size_t req_size) {
    static uint8_t *heap_curr = NULL;
    if (!heap_curr) heap_curr = heap_start;

    size_t hsz = hdr_size();
    uintptr_t curp = align_up_uintptr((uintptr_t)heap_curr, MEM_ALIGN);
    uintptr_t need = curp + hsz + req_size;
    if ((uint8_t *)need > heap_end) {
        return 0; /* cannot extend */
    }

    block_hdr_t *b = (block_hdr_t *)curp;
    b->size = req_size;
    b->free = 0;
    b->next = NULL;

    heap_curr = (uint8_t *)need;
    /* return new block by adding to used area (we will not add to free list) */
    /* but we want to return it via free list interface: we allocate directly */
    /* not used: caller handles used block */
    (void)b;
    return 1;
}

/* initialize heap (must be called once) */
void kinit(void) {
    INFO("Memory allocator initing...");
    heap_start = (uint8_t *)_heap_start;
    heap_end   = (uint8_t *)_heap_end;

    /* 确保堆的起始地址是对齐的 */
    heap_start = (uint8_t *)align_up_uintptr((uintptr_t)heap_start, MEM_ALIGN);

    /* 计算总的可用堆大小 */
    size_t heap_size = heap_end - heap_start;
    size_t hsz = hdr_size();

    /* [修复] 检查堆是否至少能容纳一个块头 */
    if (heap_size < hsz) {
        ERROR("Heap size is too small!");
        free_head = NULL;
        total_free_bytes = 0;
        total_used_bytes = 0;
        return;
    }

    /* [修复] 将整个堆初始化为第一个大的空闲块 */
    free_head = (block_hdr_t *)heap_start;
    free_head->size = heap_size - hsz; // size 是有效载荷大小, 不包括头
    free_head->next = NULL;            // 空闲链表中只有这一个块
    free_head->free = 1;               // 标记为空闲

    /* [修复] 正确初始化内存使用统计 */
    total_used_bytes = 0;
    total_free_bytes = free_head->size; // 所有有效载荷空间都是空闲的

    SUCCESS("Memory allocator init sucess.");
}

/* public: allocate aligned */
void *kalloc_aligned(size_t size, size_t alignment) {
    if (alignment == 0) alignment = MEM_ALIGN;
    if ((alignment & (alignment - 1)) != 0) return NULL; /* must be power of two */

    lock_acquire();

    size_t hsz = hdr_size();

    /* To support alignment, we may need to allocate a slightly larger block and return an aligned payload.
       We'll implement a simple strategy: allocate size + alignment extra, then adjust and possibly create a prefix header.
    */
    size_t req = size + alignment; /* generous */
    block_hdr_t *prev = NULL;
    block_hdr_t *b = find_fit(req, &prev);

    if (!b) {
        /* try extend heap */
        uintptr_t heap_curr_guess;
        /* use static local in extend_heap (it keeps track) */
        if (!extend_heap(req)) {
            lock_release();
            return NULL;
        }
        /* after extend_heap we can locate the newly created block at heap_curr - (hsz+req) */
        /* for simplicity, find fit again */
        b = find_fit(req, &prev);
        if (!b) {
            /* maybe extend created used chunk directly; fallback: return NULL */
            lock_release();
            return NULL;
        }
    }

    /* remove from free list */
    remove_free_block(prev, b);

    /* compute payload start aligned */
    uint8_t *payload = (uint8_t *)b + hsz;
    uintptr_t aligned_payload = align_up_uintptr((uintptr_t)payload, alignment);

    /* if aligned_payload is larger than payload, we may need to create a small prefix free-block */
    if (aligned_payload - (uintptr_t)payload >= (hsz + MEM_ALIGN)) {
        /* create prefix free block */
        block_hdr_t *prefix = b;
        prefix->size = (aligned_payload - (uintptr_t)payload) - hsz;
        prefix->free = 1;
        /* link prefix into free list head */
        prefix->next = free_head;
        free_head = prefix;
        total_free_bytes += prefix->size;
        /* create user block after prefix */
        b = (block_hdr_t *)( (uint8_t *)prefix + hsz + prefix->size );
        b->size = req - (prefix->size); /* approximate */
    }

    /* If block is larger than required, split */
    if (b->size > size) {
        split_block(b, size);
    }

    total_used_bytes += b->size;
    lock_release();

    return (uint8_t *)b + hsz;
}

/* public: allocate (non-aligned, default alignment) */
void *kalloc(size_t size) {
    if (size == 0) return NULL;
    /* align requested size to MEM_ALIGN */
    size = (size + (MEM_ALIGN - 1)) & ~(MEM_ALIGN - 1);

    lock_acquire();
    size_t hsz = hdr_size();

    block_hdr_t *prev = NULL;
    block_hdr_t *b = find_fit(size, &prev);
    if (!b) {
        /* try to extend heap with exactly requested size */
        /* extend_heap returns 1 if successful, but currently it doesn't return the block pointer.
           We'll implement a simpler extend logic: allocate at current heap pointer (we track heap_curr inside extend_heap)
        */
        /* call extend_heap to create an occupied block at heap */
        if (!extend_heap(size)) {
            lock_release();
            return NULL; /* OOM */
        }
        /* After extend, the new block is not in free list. But extend_heap didn't return block pointer.
           For simplicity, we try find_fit again (extend_heap might not create free blocks),
           fallback: manually construct block at heap pointer using a static notion isn't accessible here.
           To avoid complexity, we will instead create a free block from remaining heap and then find it.
        */
        /* A simpler workable approach: create a new block pointer based on a static current pointer.
           But extend_heap already advances a static heap_curr. We cannot easily retrieve that pointer here.
           To keep code robust, let's instead implement an "allocate-from-top" variant below (without free list).
        */
    }

    if (b) {
        remove_free_block(prev, b);
        if (b->size > size) split_block(b, size);
        total_used_bytes += b->size;
        lock_release();
        return (uint8_t *)b + hsz;
    }

    /* fallback: allocate from top directly (bump pointer) */
    /* We'll implement a local bump pointer here (static inside this function) */
    static uint8_t *bump_ptr = NULL;
    if (!bump_ptr) bump_ptr = heap_start;
    uintptr_t cur = align_up_uintptr((uintptr_t)bump_ptr, MEM_ALIGN);
    uintptr_t req_end = cur + hsz + size;
    if ((uint8_t *)req_end > heap_end) {
        lock_release();
        return NULL; /* OOM */
    }
    block_hdr_t *nb = (block_hdr_t *)cur;
    nb->size = size;
    nb->free = 0;
    nb->next = NULL;
    bump_ptr = (uint8_t *)req_end;
    total_used_bytes += nb->size;
    lock_release();
    return (uint8_t *)nb + hsz;
}

/* public: free block */
void kfree(void *ptr) {
    if (!ptr) return;
    lock_acquire();
    size_t hsz = hdr_size();
    block_hdr_t *b = (block_hdr_t *)((uint8_t *)ptr - hsz);
    /* mark free and insert at free_head */
    b->free = 1;
    b->next = free_head;
    free_head = b;
    total_used_bytes -= b->size;
    total_free_bytes += b->size;
    /* coalesce adjacent free blocks */
    coalesce_all();
    lock_release();
}

/* optional statistics */
size_t kmem_total_free(void) {
    return total_free_bytes;
}
size_t kmem_total_used(void) {
    return total_used_bytes;
}
